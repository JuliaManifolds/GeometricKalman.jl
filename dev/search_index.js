var documenterSearchIndex = {"docs":
[{"location":"interface/#Utilities","page":"Interface","title":"Utilities","text":"","category":"section"},{"location":"interface/#Public-documentation","page":"Interface","title":"Public documentation","text":"","category":"section"},{"location":"interface/#Internal-utilities","page":"Interface","title":"Internal utilities","text":"","category":"section"},{"location":"interface/#GeometricKalman.CovarianceMatchingMeasurementCovarianceAdapter","page":"Interface","title":"GeometricKalman.CovarianceMatchingMeasurementCovarianceAdapter","text":"Corresponds to Eq. (11) from [AZH17] with added W_n.\n\n\n\n\n\n","category":"type"},{"location":"interface/#GeometricKalman.CovarianceMatchingProcessCovarianceAdapter","page":"Interface","title":"GeometricKalman.CovarianceMatchingProcessCovarianceAdapter","text":"Corresponds to Eq. (15) from [AZH17] with added L_n.\n\n\n\n\n\n","category":"type"},{"location":"interface/#GeometricKalman.EKFPropagator","page":"Interface","title":"GeometricKalman.EKFPropagator","text":"EKFPropagator <: AbstractKFPropagator\n\nPropagation step of the extended Kalman filter.\n\n\n\n\n\n","category":"type"},{"location":"interface/#GeometricKalman.EKFUpdater","page":"Interface","title":"GeometricKalman.EKFUpdater","text":"EKFUpdater <: AbstractKFUpdater\n\nUpdate step of the extended Kalman filter.\n\n\n\n\n\n","category":"type"},{"location":"interface/#GeometricKalman.KalmanState","page":"Interface","title":"GeometricKalman.KalmanState","text":"mutable struct KalmanState end\n\nManifold Kalman filter state.\n\nThe following deterministic dynamical system is discretized:\n\nD_t y(t) = f(y(t) q(t) t) \nz(t) = h(p(t) q(t))\n\nwhere y(t) in mathcalM is state at time t, q(t) in Q are control parameters, fcolon mathcalM  mathcalN  mathbbR to TmathbbM represents state transition function and h colon mathcalM times Q to mathcalM_obs is the measurement function.\n\nNotably, when f is given by an action of a Lie group  on y(t), i.e. f(y q t) = g(y q t)  y(t) for some function gfcolon mathcalM times mathbbR to mathbbG and an action circ of group mathbbG on manifold mathbbM, the system can be solved using RKMK integrators.\n\nSuch system is a generalization of the IEKF from [BB18], where mathcalM = mathcalG and action represents either left or right group operation action.\n\nDiscrete equations are as follows:\n\n\nbeginalign*\ntildef(p q_n w_n t_n) = exp_p(Delta t f(p q_n w_n t_n)) quad  textdiscretization \np_nn-1 = tildef(p_n-1n-1 q_n w_n t_n) quad textmean propagation \nhatf(p_c q_n w_n t_n) = tildef(phi^-1_p(p_c) q_n w_n t_n) quad  textJacobian parametrization \nF_n = D_p tildef(p_n-1n-1 q_n w_n) quad textJacobian of  hatf text wrt  p_c text at  p_n-1n-1 \nL_n = D_w tildef(p_n-1n-1 q_n w_n) quad textJacobian of  tildef text wrt  w text at  p_n-1n-1 \nP_nn-1 = F_n P_n-1n-1 F_n^T + L_n Q_n(p_nn-1 q_n) L_n^T quad textcovariance propagation \nP_nn-1    texta linear operator on T_p_nn-1mathcalM \nz_n  quad textactual measurement\ny_n = log_h(p_nn-1 q_n)(z_n) quad  textmeasurement residual \nH_n = D_p h(p_nn-1 q_n) quad textJacobian of  h text wrt  p text at  p_nn-1 \nH_n    texta linear operator from T_p_nn-1mathcalM text to  T_h(p_nn-1 q_n) mathcalN \nR_n  quad  textcovariance matrix of the observation noise\nS_n = H_n P_nn-1 H_n^T + R_n quad textinnovation covariance\nS_n    texta linear operator on T_h(p_nn-1 q_n)mathcalN \nK_n = P_nn-1 H_n^T S_n^-1 quad textKalman gain\nK_n    texta linear operator from T_h(p_nn-1 q_n)mathcalN text to  T_p_nn-1 mathcalM \np_nn = exp_p_nn-1(K_n y_n) quad textupdated state estimate \nP_nn = operatornamePT_p_nn-1 to p_nn P_nn-1 - K_n S_n K_n^T quad textupdated covariance estimate \nendalign*\n\nwhere p_nm denotes estimate of p at time step n given samples up to and including the one at time m. operatornamePT represents transporting covaraince from propagated state to the one updated through measurement. It is sometimes known as \"covariance reset\", see [GGM23] and [MGH22]. phi_p is a chart around point p, phi_p colon mathcalM to mathbbR^k, and p_c = phi_p(p). \n\nNote: for linear noise, L_n is the identity matrix.\n\nFields\n\np: filter state estimate\nP: state covariance matrix coordinates\nQ: process noise\nR: measurement noise\nf_tilde: discretized transition function\njacobian_f_tilde: Jacobian of the discretized transition function\nB: basis type in which covariance and Jacobian matrices are computed\n\n\n\n\n\n","category":"type"},{"location":"interface/#GeometricKalman.UnscentedPropagator","page":"Interface","title":"GeometricKalman.UnscentedPropagator","text":"Source: E. A. Wan and R. Van Der Merwe, “The unscented Kalman filter for nonlinear estimation,” in Proceedings of the IEEE 2000 Adaptive Systems for Signal Processing, Communications, and Control Symposium (Cat. No.00EX373), Lake Louise, Alta., Canada: IEEE, 2000, pp. 153–158. doi: 10.1109/ASSPCC.2000.882463.\n\n\n\n\n\n","category":"type"},{"location":"interface/#GeometricKalman.UnscentedUpdater","page":"Interface","title":"GeometricKalman.UnscentedUpdater","text":"UnscentedUpdater\n\nUpdate step of the unscented Kalman filter.\n\n\n\n\n\n","category":"type"},{"location":"interface/#GeometricKalman.WanMerweSigmaPoints","page":"Interface","title":"GeometricKalman.WanMerweSigmaPoints","text":"WanMerweSigmaPoints <: UnscentedSigmaPoints\n\nA structure that represents the sigma points proposed by E. A. Wan and R. Van Der Merwe.\n\nSource: E. A. Wan and R. Van Der Merwe, “The unscented Kalman filter for nonlinear estimation,” in Proceedings of the IEEE 2000 Adaptive Systems for Signal Processing, Communications, and Control Symposium (Cat. No.00EX373), Lake Louise, Alta., Canada: IEEE, 2000, pp. 153–158. doi: 10.1109/ASSPCC.2000.882463.\n\n\n\n\n\n","category":"type"},{"location":"interface/#GeometricKalman.discrete_kalman_filter_manifold","page":"Interface","title":"GeometricKalman.discrete_kalman_filter_manifold","text":"discrete_kalman_filter_manifold(\n    M::AbstractManifold,\n    M_obs::AbstractManifold,\n    p0,\n    f_tilde,\n    h,\n    P0,\n    Q,\n    R;\n    kwargs...\n)\n\nConstruct a Kalman filter on manifold M.\n\nKeyword arguments\n\ncontrol_prototype=nothing: prototype of the control parameter for h and f_tilde. Can be used for constructing caches by some algorithms.\n\n\n\n\n\n","category":"function"},{"location":"interface/#StatsAPI.predict!","page":"Interface","title":"StatsAPI.predict!","text":"predict!(kalman::KalmanState, prop::EKFPropagator, control)\n\nPerform prediction step of the Kalman filter represented by KalmanState kalman with EKFPropagator propagation rule.\n\n\n\n\n\npredict!(kalman::KalmanState, prop::UnscentedPropagatorCache, control)\n\nPerform prediction step of the Kalman filter represented by KalmanState kalman with the cached variant of the UnscentedPropagator propagation rule.\n\n\n\n\n\n","category":"function"},{"location":"interface/#GeometricKalman.update!","page":"Interface","title":"GeometricKalman.update!","text":"update!(kalman::KalmanState, upd::EKFUpdater, control, measurement)\n\nPerform the update step of the Kalman filter represented by KalmanState kalman  with update rule EKFUpdater.\n\n\n\n\n\nupdate!(kalman::KalmanState, upd::UnscentedUpdaterCache, control, measurement)\n\nPerform the update step of the Kalman filter represented by KalmanState kalman  with the cached variant of the update rule UnscentedUpdater.\n\n\n\n\n\n","category":"function"},{"location":"interface/#GeometricKalman.make_kalman_parameter_fitting_objective","page":"Interface","title":"GeometricKalman.make_kalman_parameter_fitting_objective","text":"\n\n\n\n","category":"function"},{"location":"interface/#GeometricKalman.adapt_covariance!","page":"Interface","title":"GeometricKalman.adapt_covariance!","text":"HPHT is innovation covariance without measurement noise.\n\n\n\n\n\n","category":"function"},{"location":"interface/#GeometricKalman.get_inits","page":"Interface","title":"GeometricKalman.get_inits","text":"get_inits(pfo::AbstractKFOParametrization, p_opt)\n\nGet filter initialization parameters: p0, P0, Q and R, where p_opt is the set of parameters over which optimization is performed.\n\n\n\n\n\n","category":"function"},{"location":"interface/#GeometricKalman.AbstractKFOParametrization","page":"Interface","title":"GeometricKalman.AbstractKFOParametrization","text":"abstract type AbstractKFOParametrization end\n\nRepresent a nonlinear least squares fitting problem for parameters of a Kalman filter. The parameters may refer to initial conditions, noise covariance matrices, process parameters (like weight of a certain factor) or measurement parameters (like sensor bias).\n\nThe following functionality is expected:\n\nget_inits(pfo::AbstractKFOParametrization, p_opt)\nresiduals(pfo::AbstractKFOParametrization, p_opt)\n\n\n\n\n\n","category":"type"},{"location":"misc/NEWS/#Changelog","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.\n\nThe format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"section"},{"location":"misc/NEWS/#[0.1.0]-unreleased","page":"Changelog","title":"[0.1.0] unreleased","text":"Initial release. Contains:\ndiscrete_kalman_filter_manifold for constructing Kalman filters whose state is represented by KalmanState with basic predict! and update! operations defined on it.\nA set of propagation and update rules: EKFPropagator, EKFUpdater, UnscentedPropagator and UnscentedUpdater.\nBasic covariance estimation algorithms: CovarianceMatchingMeasurementCovarianceAdapter, CovarianceMatchingProcessCovarianceAdapter.\nTwo examples (gen_car_data, gen_car_sphere_data).","category":"section"},{"location":"misc/references/#Literature","page":"References","title":"Literature","text":"Usually you will find a small reference section at the end of every documentation page that contains references for just that page.\n\nS. Akhlaghi, N. Zhou and Z. Huang. Adaptive adjustment of noise covariance in Kalman filter for dynamic state estimation. In: 2017 IEEE Power & Energy Society General Meeting (Jul 2017); pp. 1–5.\n\n\n\nA. Barrau and S. Bonnabel. Invariant Kalman Filtering. Annual Review of Control, Robotics, and Autonomous Systems 1, 237–257 (2018). Publisher: Annual Reviews.\n\n\n\nY. Ge, P. v. Goor and R. Mahony. A Note on the Extended Kalman Filter on a Manifold (Sep 2023), arXiv:2309.06008.\n\n\n\nR. Mahony, P. v. Goor and T. Hamel. Observer Design for Nonlinear Systems with Equivariance. Annual Review of Control, Robotics, and Autonomous Systems 5, 221–252 (2022).\n\n\n\n","category":"section"},{"location":"#GeometricKalman","page":"Home","title":"GeometricKalman","text":"Kalman filters on manifolds with an affine connection, unifying the Lie group and Riemannian approaches.\n\n(Image: )\n\narXiv preprint: https://arxiv.org/abs/2506.01086.","category":"section"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"Basic setting (example: a car driving on a sphere)\n\n\nusing Manifolds\nusing RecursiveArrayTools\nusing LinearAlgebra\n\nusing Distributions\n\nusing GeometricKalman\nusing GeometricKalman: gen_car_sphere_data, car_sphere_f, car_sphere_h\n\nM = TangentBundle(Manifolds.Sphere(2)) # state manifold\nM_obs = Manifolds.Sphere(2) # observation manifold\nretraction = Manifolds.FiberBundleProductRetraction()\ninverse_retraction = Manifolds.FiberBundleInverseProductRetraction()\n\nGenerating data using the gen_car_sphere_data function.\n\ndt = 0.01\nvt = 5\n\ntimes, samples, controls, measurements = gen_car_sphere_data(;\n    vt = vt,\n    N = 200,\n    noise_f_distr = MvNormal(\n        [0.0, 0.0, 0.0, 0.0],\n        1e4 * diagm([1e-3, 1e-3, 1e-2, 1e-2]),\n    ),\n    noise_h_distr = MvNormal([0.0, 0.0], diagm([0.01, 0.01])),\n    retraction = retraction,\n)\n\nSetting initial conditions for filters\n\np0 = ArrayPartition([1.0, 0.0, 0.0], [0.0, 1.0, 0.0])\nP0 = diagm([0.1, 0.1, 0.1, 0.1])\nQ = diagm([0.1, 0.1, 0.01, 0.01])\nR = diagm([0.01, 0.01])\n\n\nAdapting system dynamics to the interface expected by Kalman filters.\n\n\ncar_f_adapted(p, q, noise, t::Real) = car_sphere_f(p, q, noise, t::Real; vt = vt)\nf_tilde = GeometricKalman.default_discretization(\n    M,\n    car_f_adapted;\n    dt = dt,\n    retraction = retraction,\n)\n\n\nFilter-specific settings\n\n\nsp = WanMerweSigmaPoints(; α = 1.0)\nfilter_params = [\n    ( # extended Kalman filter\n        \"EKF\",\n        (;\n            propagator = EKFPropagator(M, f_tilde; B_M = DefaultOrthonormalBasis()),\n            updater = EKFUpdater(\n                M,\n                M_obs,\n                car_sphere_h;\n                B_M = DefaultOrthonormalBasis(),\n                B_M_obs = DefaultOrthonormalBasis(),\n            ),\n        ),\n    ),\n    ( # unscented Kalman filter\n        \"UKF\", \n        (;\n            propagator = UnscentedPropagator(\n                M;\n                sigma_points = sp,\n                inverse_retraction_method = inverse_retraction,\n            ),\n            updater = UnscentedUpdater(; sigma_points = sp),\n        ),\n    ),\n    ( # adaptive extended Kalman filter\n        \"EKF adaptive M α=0.99\",\n        (;\n            propagator = EKFPropagator(M, f_tilde; B_M = DefaultOrthonormalBasis()),\n            updater = EKFUpdater(\n                M,\n                M_obs,\n                car_sphere_h;\n                B_M = DefaultOrthonormalBasis(),\n                B_M_obs = DefaultOrthonormalBasis(),\n            ),\n            measurement_covariance_adapter = CovarianceMatchingMeasurementCovarianceAdapter(\n                0.99,\n            ),\n        ),\n    ),\n]\n\n\nRunning the filters. Results will be saved in reconstructions.\n\nreconstructions = NamedTuple[]\n\nfor (name, filter_kwargs) in filter_params\n    kf = discrete_kalman_filter_manifold(\n        M,\n        M_obs,\n        p0,\n        f_tilde,\n        car_sphere_h,\n        P0,\n        copy(Q),\n        copy(R);\n        filter_kwargs...,\n    )\n\n    samples_kalman = []\n    for i in eachindex(samples)\n        GeometricKalman.update!(kf, controls[i], measurements[i])\n        push!(samples_kalman, kf.p_n)\n        predict!(kf, controls[i])\n    end\n    push!(reconstructions, (; data = samples_kalman, label = name))\nend\n\n\nPlotting the estimated trajectory and measurements.\n\n\nusing Plots\n\nfunction trajectory_plot3d(\n    p0,\n    samples::Vector,\n    reconstructions::Vector{<:NamedTuple},\n    measurements::Vector,\n)\n    fig = plot(\n        [s.x[1][1] for s in samples],\n        [s.x[1][2] for s in samples],\n        [s.x[1][3] for s in samples];\n        label = \"original\",\n        linewidth = 5.0,\n    )\n    scatter3d!(map(v -> [v], p0.x[1])..., markersize = 15, label = \"Starting point\")\n\n    for rec in reconstructions\n        plot!(\n            [s.x[1][1] for s in rec.data],\n            [s.x[1][2] for s in rec.data],\n            [s.x[1][3] for s in rec.data];\n            label = rec.label,\n        )\n    end\n\n    scatter!(\n        [s[1] for s in measurements],\n        [s[2] for s in measurements],\n        [s[3] for s in measurements];\n        label = \"measurements\",\n    )\n    return fig\nend\n\n\ntrajectory_plot3d(p0, samples, reconstructions, measurements)","category":"section"}]
}
